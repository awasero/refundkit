---
title: "The Developer's Guide to Programmatic Refunds"
description: "Everything developers need to know about building programmatic refund flows: lifecycle, idempotency, webhooks, testing, and monitoring."
date: "2024-01-03T10:00:00.000Z"
author: "RefundKit Team"
tags: ["guide", "sdk", "best-practices"]
slug: "developers-guide-to-programmatic-refunds"
---

## Introduction

Processing a refund seems simple on the surface. Call an API, the money goes back. But production refund systems are full of subtlety. What happens when the network drops midway through a refund request? How do you prevent a retry from creating a duplicate refund? How do you know when a refund that was "processing" an hour ago has actually completed? What does your test suite look like when every test involves actual money?

These are the questions that separate a prototype refund integration from a production-grade one. If you have built payment integrations before, you know that the devil is in the details. Refunds have their own set of details that deserve careful attention.

This guide covers the full lifecycle of programmatic refunds: from the moment a refund is requested to long after it has been completed. We will cover the refund state machine, idempotency patterns, webhook handling, testing strategies, monitoring, and the best practices that keep refund systems reliable at scale.

## The Refund Lifecycle

Every refund moves through a series of states. Understanding this lifecycle is the foundation for building robust refund integrations.

### State Machine

A refund typically moves through these states:

```
[Created] -> [Pending] -> [Processing] -> [Completed]
                |              |
                v              v
           [Cancelled]      [Failed]
```

Here is what each state means:

- **Pending**: The refund has been created in the system but has not yet been submitted to the payment processor. This is the initial state.
- **Processing**: The refund has been submitted to the payment processor and is awaiting confirmation. Depending on the processor, this state can last from seconds to days.
- **Completed**: The payment processor has confirmed the refund. The money is on its way back to the customer (though the customer may not see it for 5-10 business days depending on their bank).
- **Failed**: The refund could not be processed. Common reasons include insufficient funds in the merchant's account, the original charge being too old, or the payment method being invalid.
- **Cancelled**: The refund was cancelled before it was completed, either by a human or an agent.

In code, the RefundKit SDK represents these states as a union type:

```typescript
type RefundStatus =
  | 'pending'
  | 'processing'
  | 'completed'
  | 'failed'
  | 'cancelled';
```

### Creating a Refund

The starting point is creating a refund with the required parameters:

```typescript
import RefundKit from '@refundkit/sdk';

const rk = new RefundKit({
  apiKey: process.env.REFUNDKIT_API_KEY,
});

const { data: refund, error } = await rk.refunds.create({
  transactionId: 'ch_1abc2def3ghi',
  amount: 4999,           // $49.99 in cents
  reason: 'product_defective',
  currency: 'usd',        // optional, defaults to 'usd'
  metadata: {              // optional, arbitrary key-value pairs
    orderId: 'order_123',
    customerId: 'cust_456',
    supportTicket: 'ticket_789',
  },
});

if (error) {
  console.error(`Refund creation failed: [${error.code}] ${error.message}`);
  // Handle specific error codes
  return;
}

console.log(`Refund created: ${refund.id}, status: ${refund.status}`);
```

A few things to note about this call:

**Amounts are in smallest currency units.** For USD, this means cents. $49.99 is `4999`. This avoids floating-point precision issues that plague systems using decimal amounts.

**Reason codes are enumerated.** The SDK accepts a specific set of reason codes: `product_not_received`, `product_defective`, `wrong_product`, `duplicate_charge`, `subscription_cancelled`, and `other`. Using structured reason codes rather than free-text strings enables analytics, policy enforcement, and processor-level categorization.

**Metadata is your escape hatch.** The metadata field accepts arbitrary key-value pairs. Use it to attach context that is relevant to your application: order IDs, customer IDs, support ticket numbers, agent identifiers, or any other reference data. This metadata is stored with the refund and returned in all subsequent queries.

**The response uses a `{ data, error }` pattern.** Rather than throwing exceptions, the SDK returns a structured response. This makes error handling explicit and avoids the try/catch overhead for expected error conditions like validation failures.

### Tracking Refund Status

After creating a refund, you need to track its progress. There are two approaches: polling and webhooks. We will cover webhooks in a dedicated section below. For polling:

```typescript
const { data: refund, error } = await rk.refunds.get('ref_abc123');

if (error) {
  console.error(`Failed to fetch refund: ${error.message}`);
  return;
}

console.log(`Refund ${refund.id}: ${refund.status}`);
console.log(`Processor: ${refund.processor}`);
console.log(`External ID: ${refund.externalRefundId}`);
console.log(`Created: ${refund.createdAt}`);
console.log(`Updated: ${refund.updatedAt}`);
```

For bulk monitoring, use the list endpoint with filters:

```typescript
// Get all processing refunds
const { data: processingRefunds } = await rk.refunds.list({
  status: 'processing',
  limit: 100,
  offset: 0,
});

// Get all Stripe refunds
const { data: stripeRefunds } = await rk.refunds.list({
  processor: 'stripe',
  limit: 50,
});

// Get all failed refunds for investigation
const { data: failedRefunds } = await rk.refunds.list({
  status: 'failed',
  limit: 25,
});
```

## Idempotency

Idempotency is the single most important property of a refund system. Without it, network failures, retries, and race conditions can result in double refunds -- one of the most painful bugs in payments engineering.

### The Problem

Consider this sequence of events:

1. Your application sends a refund request to the API
2. The API receives the request and processes the refund
3. The API sends back a success response
4. The network drops the response before your application receives it
5. Your application sees a timeout error and retries the request
6. The API receives the retry and processes a second refund

The customer gets refunded twice. Your company loses money. Your CFO is unhappy.

### The Solution

Idempotency ensures that processing the same request twice produces the same result as processing it once. There are several layers where idempotency can be enforced:

**Transaction-level deduplication.** Before creating a new refund, check if one already exists for the same transaction. If a non-failed refund exists for the same transaction with the same amount, return the existing refund instead of creating a new one:

```typescript
async function processRefundIdempotently(
  rk: RefundKit,
  params: CreateRefundParams,
): Promise<Refund> {
  // Check for existing refund on this transaction
  const { data: existing } = await rk.refunds.list({
    // In production, you would filter by transactionId on the server side
    limit: 100,
  });

  const duplicate = existing?.find(
    r =>
      r.transactionId === params.transactionId &&
      r.amount === params.amount &&
      r.status !== 'failed' &&
      r.status !== 'cancelled'
  );

  if (duplicate) {
    console.log(`Returning existing refund: ${duplicate.id}`);
    return duplicate;
  }

  const { data: refund, error } = await rk.refunds.create(params);
  if (error) throw error;
  return refund;
}
```

**Client-side request tracking.** Maintain a local record of in-flight requests. Before sending a request, check if an identical request is already pending. This prevents retries from creating duplicate requests at the application level:

```typescript
const pendingRefunds = new Map<string, Promise<Refund>>();

async function createRefundOnce(params: CreateRefundParams): Promise<Refund> {
  const key = `${params.transactionId}:${params.amount}:${params.reason}`;

  if (pendingRefunds.has(key)) {
    return pendingRefunds.get(key);
  }

  const promise = rk.refunds.create(params).then(({ data, error }) => {
    pendingRefunds.delete(key);
    if (error) throw error;
    return data;
  });

  pendingRefunds.set(key, promise);
  return promise;
}
```

**Database-level constraints.** At the persistence layer, use unique constraints to prevent duplicate refunds from being stored even if the application-level checks fail. This is your last line of defense.

## Webhook Handling

Polling is straightforward but inefficient. For production systems, webhooks provide real-time notifications when refund status changes.

### Setting Up a Webhook Endpoint

A webhook endpoint receives POST requests from the refund system with the current state of the refund. Here is a robust implementation:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import Stripe from 'stripe';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;

export async function POST(request: NextRequest) {
  const signature = request.headers.get('stripe-signature');

  if (!signature) {
    return NextResponse.json(
      { error: 'Missing stripe-signature header' },
      { status: 400 },
    );
  }

  let event: Stripe.Event;

  try {
    const body = await request.text();
    event = stripe.webhooks.constructEvent(body, signature, webhookSecret);
  } catch (err) {
    console.error('Webhook signature verification failed:', err.message);
    return NextResponse.json(
      { error: 'Invalid signature' },
      { status: 400 },
    );
  }

  switch (event.type) {
    case 'charge.refund.updated': {
      const refund = event.data.object as Stripe.Refund;
      await handleRefundUpdate(refund);
      break;
    }
    case 'charge.refunded': {
      const charge = event.data.object as Stripe.Charge;
      await handleChargeRefunded(charge);
      break;
    }
    default:
      console.log(`Unhandled event type: ${event.type}`);
  }

  return NextResponse.json({ received: true });
}

async function handleRefundUpdate(refund: Stripe.Refund): Promise<void> {
  // Update the refund status in your database
  await db.refund.update({
    where: { externalRefundId: refund.id },
    data: {
      status: mapStripeStatus(refund.status),
      updatedAt: new Date().toISOString(),
    },
  });

  // Notify the customer if the refund completed or failed
  if (refund.status === 'succeeded') {
    await notifyCustomer(refund, 'Your refund has been processed successfully.');
  } else if (refund.status === 'failed') {
    await notifyCustomer(refund, 'There was an issue with your refund. Our team is looking into it.');
    await alertOpsTeam(refund);
  }
}
```

### Webhook Best Practices

**Always verify signatures.** Never process a webhook without verifying its cryptographic signature. Without verification, anyone who discovers your webhook URL can send fake events.

**Respond quickly, process asynchronously.** Webhook providers expect a response within a few seconds. If your processing logic takes longer, acknowledge the webhook immediately and process the event asynchronously:

```typescript
export async function POST(request: NextRequest) {
  // Verify signature...

  // Acknowledge immediately
  await queue.enqueue('process_webhook', { eventId: event.id, payload: event });

  return NextResponse.json({ received: true });
}
```

**Handle out-of-order delivery.** Webhooks can arrive out of order. A "completed" event might arrive before the "processing" event. Use the refund's `updatedAt` timestamp to determine the correct order and ignore stale updates:

```typescript
async function handleRefundUpdate(refund: Stripe.Refund): Promise<void> {
  const existing = await db.refund.findUnique({
    where: { externalRefundId: refund.id },
  });

  if (!existing) {
    console.warn(`Received webhook for unknown refund: ${refund.id}`);
    return;
  }

  // Only update if this event is newer
  const eventTime = new Date(refund.created * 1000);
  const existingTime = new Date(existing.updatedAt);

  if (eventTime <= existingTime) {
    console.log(`Ignoring stale webhook for refund: ${refund.id}`);
    return;
  }

  await db.refund.update({
    where: { id: existing.id },
    data: {
      status: mapStripeStatus(refund.status),
      updatedAt: eventTime.toISOString(),
    },
  });
}
```

**Implement idempotent webhook handling.** Webhook providers retry on failure, so you may receive the same event multiple times. Use the event ID to deduplicate:

```typescript
async function processWebhook(event: Stripe.Event): Promise<void> {
  // Check if we have already processed this event
  const processed = await db.webhookEvent.findUnique({
    where: { eventId: event.id },
  });

  if (processed) {
    console.log(`Already processed event: ${event.id}`);
    return;
  }

  // Process the event...

  // Mark as processed
  await db.webhookEvent.create({
    data: { eventId: event.id, processedAt: new Date().toISOString() },
  });
}
```

## Testing with Test Keys

Testing refund flows requires a strategy that lets you exercise the full lifecycle without involving real money.

### Test Mode vs Live Mode

RefundKit supports separate test and live API keys. Test keys (`rk_test_...`) connect to a sandbox environment where refunds are simulated:

```typescript
// Test environment
const rkTest = new RefundKit({
  apiKey: 'rk_test_abc123',
});

// Live environment
const rkLive = new RefundKit({
  apiKey: 'rk_live_xyz789',
});
```

In test mode:
- Refunds are created but not submitted to payment processors
- Status transitions are simulated
- Webhooks can be triggered manually for testing
- No real money moves

### Unit Testing with the SDK

For unit tests, you can mock the RefundKit client to test your application logic without making API calls:

```typescript
import { describe, it, expect, vi } from 'vitest';

// Mock the SDK
vi.mock('@refundkit/sdk', () => ({
  default: vi.fn().mockImplementation(() => ({
    refunds: {
      create: vi.fn(),
      get: vi.fn(),
      list: vi.fn(),
      cancel: vi.fn(),
    },
    policies: {
      check: vi.fn(),
    },
  })),
}));

import RefundKit from '@refundkit/sdk';
import { processCustomerRefund } from '../src/refund-service';

describe('RefundService', () => {
  it('should check policy before processing refund', async () => {
    const rk = new RefundKit({ apiKey: 'rk_test_mock' });

    // Mock policy check -- eligible
    (rk.policies.check as ReturnType<typeof vi.fn>).mockResolvedValue({
      data: {
        eligible: true,
        reason: 'Within return window',
        maxAmount: 9999,
        deadline: '2024-02-15T00:00:00.000Z',
        conditions: [],
      },
      error: null,
    });

    // Mock refund creation
    (rk.refunds.create as ReturnType<typeof vi.fn>).mockResolvedValue({
      data: {
        id: 'ref_test_001',
        status: 'pending',
        amount: 4999,
        transactionId: 'tx_test_001',
        reason: 'product_defective',
        processor: 'stripe',
        initiatedBy: 'api',
        createdAt: '2024-01-15T10:00:00.000Z',
        updatedAt: '2024-01-15T10:00:00.000Z',
      },
      error: null,
    });

    const result = await processCustomerRefund(rk, {
      transactionId: 'tx_test_001',
      amount: 4999,
      reason: 'product_defective',
    });

    expect(rk.policies.check).toHaveBeenCalledWith({
      transactionId: 'tx_test_001',
      amount: 4999,
    });
    expect(rk.refunds.create).toHaveBeenCalled();
    expect(result.id).toBe('ref_test_001');
  });

  it('should reject refund when policy is not eligible', async () => {
    const rk = new RefundKit({ apiKey: 'rk_test_mock' });

    (rk.policies.check as ReturnType<typeof vi.fn>).mockResolvedValue({
      data: {
        eligible: false,
        reason: 'Return window expired',
        maxAmount: null,
        deadline: null,
        conditions: [],
      },
      error: null,
    });

    await expect(
      processCustomerRefund(rk, {
        transactionId: 'tx_old',
        amount: 4999,
        reason: 'product_defective',
      }),
    ).rejects.toThrow('Not eligible for refund');

    expect(rk.refunds.create).not.toHaveBeenCalled();
  });
});
```

### Integration Testing

For integration tests, use test keys to verify the full flow against the sandbox API:

```typescript
import { describe, it, expect } from 'vitest';
import RefundKit from '@refundkit/sdk';

describe('Refund Integration', () => {
  const rk = new RefundKit({
    apiKey: process.env.REFUNDKIT_TEST_API_KEY,
  });

  it('should create and retrieve a refund', async () => {
    // Create
    const { data: created, error: createError } = await rk.refunds.create({
      transactionId: 'tx_integration_test_001',
      amount: 1000,
      reason: 'duplicate_charge',
    });

    expect(createError).toBeNull();
    expect(created.status).toBe('pending');
    expect(created.amount).toBe(1000);

    // Retrieve
    const { data: fetched, error: fetchError } = await rk.refunds.get(created.id);

    expect(fetchError).toBeNull();
    expect(fetched.id).toBe(created.id);
    expect(fetched.transactionId).toBe('tx_integration_test_001');
  });

  it('should cancel a pending refund', async () => {
    const { data: refund } = await rk.refunds.create({
      transactionId: 'tx_integration_test_002',
      amount: 500,
      reason: 'other',
    });

    const { data: cancelled, error } = await rk.refunds.cancel(refund.id);

    expect(error).toBeNull();
    expect(cancelled.status).toBe('cancelled');
  });
});
```

## Monitoring Refund Health

In production, you need visibility into the health of your refund system. Here are the key metrics to track.

### Key Metrics

**Refund success rate.** The percentage of refunds that reach `completed` status. A healthy system should be above 98%. A sudden drop indicates a processor issue or a bug in your integration.

**Processing time.** The time between refund creation and completion. This varies by processor (Stripe is typically minutes; bank transfers can take days), but unexpected spikes indicate problems.

**Failure rate by reason.** Track which reason codes are associated with the most failures. A spike in `duplicate_charge` failures might indicate a billing bug that needs fixing.

**Refund-to-transaction ratio.** The percentage of transactions that result in refunds. A sudden increase might indicate a product quality issue, a fraudulent pattern, or an agent misconfiguration.

### Building a Health Dashboard

Here is a pattern for computing refund health metrics:

```typescript
interface RefundHealthMetrics {
  totalRefunds: number;
  byStatus: Record<string, number>;
  successRate: number;
  avgProcessingTimeMs: number;
  failuresByReason: Record<string, number>;
}

async function computeRefundHealth(
  rk: RefundKit,
  timeWindowHours: number = 24,
): Promise<RefundHealthMetrics> {
  const { data: allRefunds } = await rk.refunds.list({ limit: 100 });

  const cutoff = new Date(Date.now() - timeWindowHours * 60 * 60 * 1000);
  const refunds = allRefunds.filter(r => new Date(r.createdAt) >= cutoff);

  const byStatus: Record<string, number> = {};
  const failuresByReason: Record<string, number> = {};
  let totalProcessingTime = 0;
  let completedCount = 0;

  for (const refund of refunds) {
    byStatus[refund.status] = (byStatus[refund.status] || 0) + 1;

    if (refund.status === 'completed') {
      completedCount++;
      const created = new Date(refund.createdAt).getTime();
      const updated = new Date(refund.updatedAt).getTime();
      totalProcessingTime += updated - created;
    }

    if (refund.status === 'failed') {
      failuresByReason[refund.reason] = (failuresByReason[refund.reason] || 0) + 1;
    }
  }

  const terminalRefunds = refunds.filter(
    r => r.status === 'completed' || r.status === 'failed',
  );

  return {
    totalRefunds: refunds.length,
    byStatus,
    successRate: terminalRefunds.length > 0
      ? completedCount / terminalRefunds.length
      : 1,
    avgProcessingTimeMs: completedCount > 0
      ? totalProcessingTime / completedCount
      : 0,
    failuresByReason,
  };
}
```

### Alerting

Set up alerts for these conditions:

- **Success rate drops below 95%** -- Indicates a systemic issue
- **Average processing time exceeds 2x the normal baseline** -- Indicates a processor delay
- **More than N failed refunds in an hour** -- Indicates a potential outage
- **Refund-to-transaction ratio exceeds threshold** -- Indicates a product or fraud issue

```typescript
async function checkRefundAlerts(): Promise<void> {
  const metrics = await computeRefundHealth(rk, 1); // Last hour

  if (metrics.successRate < 0.95) {
    await alert('Refund success rate dropped to ' +
      `${(metrics.successRate * 100).toFixed(1)}%`);
  }

  if (metrics.byStatus['failed'] > 10) {
    await alert(`${metrics.byStatus['failed']} refunds failed in the last hour`);
  }

  const avgProcessingSeconds = metrics.avgProcessingTimeMs / 1000;
  if (avgProcessingSeconds > 300) { // 5 minutes
    await alert(`Average refund processing time: ${avgProcessingSeconds.toFixed(0)}s`);
  }
}
```

## Best Practices Summary

Here are the key best practices for building production refund systems, distilled from everything we have covered:

1. **Use smallest currency units.** Always work with integers (cents, not dollars) to avoid floating-point precision issues.

2. **Implement idempotency at every layer.** Client-side deduplication, server-side idempotency keys, and database-level unique constraints. Belt, suspenders, and duct tape.

3. **Validate before processing.** Check refund policies, verify transaction existence, and validate amounts before submitting to the processor. Failing early saves time and prevents confusing error states.

4. **Handle all status transitions.** Your code should account for every possible refund status, including unexpected ones. Use exhaustive switch statements or a default handler.

5. **Log everything.** Refund operations involve money. Log every request, every response, every status change, and every error. When something goes wrong (and it will), you will need these logs.

6. **Test with real-world scenarios.** Beyond happy-path tests, simulate network timeouts, processor downtime, duplicate requests, partial refunds, and out-of-order webhooks.

7. **Monitor actively.** Do not wait for customers to tell you refunds are failing. Set up dashboards and alerts that give you real-time visibility into refund health.

8. **Separate test and live keys.** Never use live API keys in development or testing. Use test keys that connect to sandbox environments where no real money moves.

9. **Attach metadata.** Every refund should carry context: who initiated it, why, and any relevant reference IDs. This metadata is invaluable for debugging and audit.

10. **Design for failure.** Assume that any network call can fail, any processor can go down, and any webhook can be delayed. Build retry logic, fallback paths, and graceful degradation into your refund flow.

## Conclusion

Programmatic refunds are a critical piece of any commerce system, and they deserve the same engineering rigor as your payment acceptance flow. The lifecycle is more complex than it appears, idempotency is non-negotiable, webhook handling requires careful attention to ordering and deduplication, and monitoring is essential for catching problems before they become crises.

The good news is that these problems are well-understood and have well-established solutions. By following the patterns in this guide -- structured state machines, multi-layer idempotency, robust webhook handling, comprehensive testing, and proactive monitoring -- you can build a refund system that is reliable, auditable, and maintainable.

Start with the fundamentals: get the lifecycle right, implement idempotency, and set up basic monitoring. Then layer on the advanced patterns as your volume and complexity grow. Your future self (and your finance team) will thank you.
